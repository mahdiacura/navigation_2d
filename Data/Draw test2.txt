        QMatrix4x4 matrix;
		matrix.perspective(60.0f, 4.0f/3.0f, 0, 1000);
//		matrix.rotate(0, 0, 0, 0);
//		matrix.translate(0 - m_dijkstra.m_centerOfMap.m_x,
//						 -3 - m_dijkstra.m_centerOfMap.m_z,
//						 -18 - m_dijkstra.m_centerOfMap.m_y);
		matrix.translate(0 - m_shortestPath[0].m_x,
						 -0.03 - 0,
						 - m_shortestPath[0].m_y);//m_dijkstra.m_area.m_top
		matrix.rotate(0, 0, 0, 0);
        m_program->setUniformValue(m_matrixUniform, matrix);



.........


		float_t const xOffset = m_shortestPath[0].m_x;
			float_t const yOffset = 0;
			float_t const zOffset = m_shortestPath[0].m_y;
			float dx = (m_dijkstra.m_area.m_right - m_dijkstra.m_area.m_left) / 2;
			float dy = (m_dijkstra.m_area.m_top - m_dijkstra.m_area.m_bottom) / 2;
			GLdouble objectVertices[] = {
				-dx + xOffset,	0 + yOffset,	-dy + zOffset,
				dx + xOffset,	0 + yOffset,	-dy + zOffset,
				dx + xOffset,	0 + yOffset,	dy + zOffset,
				-dx + xOffset,	0 + yOffset,	dy + zOffset,
			};
			GLfloat objectColors[] = {
				0, 0.6, 1,
				0, 0.6, 1,
				0, 0.6, 1,
				0, 0.6, 1,
			};
			glVertexAttribPointer(m_positionAttribute, 3, GL_DOUBLE, GL_FALSE, 0, objectVertices);
			glVertexAttribPointer(m_colorAttribute, 3, GL_FLOAT, GL_FALSE, 0, objectColors);
			glEnableVertexAttribArray(m_positionAttribute);
			glEnableVertexAttribArray(m_colorAttribute);
			glLineWidth(2);
			glDrawArrays(GL_QUADS, 0, 4);
			glDisableVertexAttribArray(m_colorAttribute);
			glDisableVertexAttribArray(m_positionAttribute);